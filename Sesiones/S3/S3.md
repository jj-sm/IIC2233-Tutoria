# Generadores

---

Cualquier función que use un `yield` como return, o generadores por compresión.

```python
from math import pi  
  
def digits_of_pi():  
    i = -1  
    while True:  
        i += 1  
        yield str(pi)[i]  
  
if __name__ == "__main__":  
    generator = digits_of_pi()  
  
    for i in range(1000):  
        print(generator.__next__())
```

---

Por compresión

```python
gen = (i**2 for i in range(10))  
  
print(gen)  
print(list(gen))
```


---

![[Screenshot 2025-09-23 at 12.31.14 PM.png]]

---

![[../Resources/Pasted image 20250923123304.png]]

---

`send()?`

---
#  Generadores y `.send()` en Python

También pueden **recibir valores externos** usando el método `.send()`.

---

## Concepto

- Cuando usamos `yield`, el generador **pausa** su ejecución y recuerda su estado.
- Normalmente, reanudamos la ejecución con `next()`.
- Con `.send(valor)`, no solo reanudamos la ejecución, sino que **inyectamos un valor** en el `yield`.

Ese valor se asigna a la expresión del `yield`.

---

```python
def eco():
    while True:
        recibido = yield
        print("Me enviaron:", recibido)

gen = eco()
next(gen)          # Avanza hasta el primer yield
gen.send("Hola")   # Me enviaron: Hola
gen.send("Mundo")  # Me enviaron: Mundo
```

El primer `next(gen)` es necesario para "inicializar" el generador antes de usar `.send()`.

---


```python
def acumulador():
    total = 0
    while True:
        n = yield total
        if n is not None:
            total += n
        if n is None:
	        total += 2

gen = acumulador()
print(next(gen))     # 0 (inicial)
print(gen.send(10)) 
print(gen.send(5))  
print(gen.send(7)) 
print('\n')
print(next(gen))  
print(next(gen))  
```


---
# Excepciones


---

- **`else`**:  
  Se ejecuta **solo si no ocurrió ninguna excepción** en el bloque `try`.  
  Útil para código que debe correrse únicamente cuando todo salió bien.

- **`finally`**:  
  Se ejecuta **siempre**, haya ocurrido o no una excepción.  
  Normalmente se usa para **liberar recursos** (cerrar archivos, conexiones, etc.).

---

Existen distintos tipos de excepciones, donde se pueden manejar mediante el uso de:

```python
word = 'no'
try:
	print('Hello World')
except ValueError:
	print('Ups, ValueError')
except TypeError as e:
	print(f'Ups, this happened {e}')
except TimeoutError:
	word = 'yes'
else:
	print('Success')
finally:
	print('Un respiro')
```

---

Además podemos crear nuestras excepciones personalizadas, y levantar excepciones con `raise()`

---

![[Screenshot 2025-09-23 at 12.30.55 PM.png]]

---

```python
try:
	try:
		print('TRY' + 1)
	except:
		print('EXCEPCION1')
except:
	print('EXCEPCION2')
else:
	print('ELSE')
finally:
	print('FINALLY')
```

---

```python
print('TRY' + 1)
```

---

![[../Resources/Pasted image 20250923123423.png]]

---
# Git

![[../Resources/Pasted image 20250923122955.png]]

---

![[Screenshot 2025-09-23 at 12.39.57 PM.png]]

---

# Programación Funcional

- Generadores
- Funciones Generadoras

---
## Funciones Generadoras

- `map(fun, iterable)`
- `zip(iter_1, iter_2)`
- `filter(fun, iterable)`

- `enumerate(iterable)`
- `reduce(fun, itreable)

---

## `map(func, iterable)`

Aplica una función a cada elemento del iterable y devuelve un generador.

```python
nums = [1, 2, 3, 4, 5]
cuadrados = map(lambda x: x**2, nums)
print(list(cuadrados))
```

---

## `filter(func, iterable)`
Filtra elementos de un iterable según una condición (función booleana).

```python
nums = [1, 2, 3, 4, 5, 6]
pares = filter(lambda x: x % 2 == 0, nums)
print(list(pares))
```

---

## `zip(iter1, iter2, ...)`
Combina varios iterables en **tuplas emparejadas**.

```python
nombres = ["Ana", "Beto", "Carlos"]
edades = [20, 25, 30]
combinados = zip(nombres, edades)
print(list(combinados))  
```

---

```python
nombres = ["Ana", "Beto", "Carlos", "Juan"]
edades = [20, 25, 30]
combinados = zip(nombres, edades)
print(list(combinados))  
```


```python
nombres = ["Ana", "Beto", "Carlos"]
edades = [20, 25, 30, 45]
combinados = zip(nombres, edades)
print(list(combinados))  
```

---

```python
from itertools import zip_longest
  
list1 = [1, 2, 3]  
list2 = ['a', 'b']  
list3 = ['X', 'Y', 'Z', 'W']  
  
result_default = list(zip_longest(list1, list2, list3))  
print(f"(1): {result_default}")  
  
result_custom = list(zip_longest(list1, list2, list3, fillvalue='-'))  
print(f"(2): {result_custom}")
```

---

## `enumerate(iterable, start=0)`
Devuelve pares `(índice, valor)` al recorrer un iterable.

```python
frutas = ["manzana", "pera", "uva"]
for i, fruta in enumerate(frutas, start=1):
    print(i, fruta)
```

---

```python
weekdays = ['Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes']
mydict = enumerate(weekdays)
print(type(mydict))
print(dict(mydict))
```

---

## `reduce(func, iterable)` 
Aplica acumulativamente una función binaria a los elementos de un iterable.  

Es como "plegar" la lista en un único valor.

```python
from functools import reduce

listas = [[1, 2], [3, 4], [5, 6, 7]]
unida = reduce(lambda a, b: a + b, listas)
print(unida)
```

---

```python
listas = [[1, 2], [3, 4], [5, 6, 7]]  
unida = []  
for lista in listas:  
	print("---\n")
	print(f"{unida} + {lista}")
	unida += lista  
	print(f"= {unida}")
print(unida)
```

---

```python
fonda = {
	'Choripan': 4,
	'Sopaipillas': 3,
	'Anticucho': 6,
	'Asado': 0,
}

var_1 = filter(lambda x: len(x) > 0, fonda.keys())
var_2 = map(lambda x: x * 2 , filter(lambda x: x % 2 == 0, fonda.values()))

print(list(zip(var_1, var_2)))
```

---


![[../Resources/Pasted image 20250923124208.png]]

---
