
# OOP Avanzado

## Herencia  
La **herencia** permite crear nuevas clases a partir de clases existentes, reutilizando atributos y métodos.  

### Herencia  
- Una clase hija (subclase) **hereda** de una clase padre (superclase).  
- Sintaxis en Python:  
```python
class Padre:
    def saludar(self):
        print("Hola desde Padre")

class Hijo(Padre):
    pass

h = Hijo()
h.saludar()  # Hola desde Padre
```

### Sobreescritura  
- Una subclase puede redefinir métodos de la superclase.  
- Se puede usar `super()` para invocar el comportamiento original.  
```python
class Padre:
    def saludar(self):
        print("Hola desde Padre")

class Hijo(Padre):
    def saludar(self):
        super().saludar()
        print("Y también hola desde Hijo")

Hijo().saludar()
# Hola desde Padre
# Y también hola desde Hijo
```

---

## Polimorfismo  
El **polimorfismo** se refiere a la capacidad de objetos de distintas clases de responder al mismo mensaje (método) de distintas formas.  

### Overriding (Redefinición)  
Cuando una subclase redefine un método de la clase padre.  
```python
class Ave:
    def volar(self):
        print("Vuelo genérico")

class Aguila(Ave):
    def volar(self):
        print("Vuelo alto y rápido")

class Pinguino(Ave):
    def volar(self):
        print("No vuelo, nado")
```

### Overloading (Sobrecarga)  
Python **no soporta sobrecarga de funciones** como en Java o C++.  
- Se simula usando valores por defecto o `*args, **kwargs`:  
```python
def area(a, b=None):
    if b is None:
        return 3.14 * a * a
    return a * b

print(area(5))     # círculo
print(area(4, 6))  # rectángulo
```

### `__repr__` y `__str__`  
- `__str__`: representación "amigable" para el usuario.  
- `__repr__`: representación formal, útil para debugging.  
```python
class Persona:
    def __init__(self, nombre, edad):
        self.nombre = nombre
        self.edad = edad

    def __str__(self):
        return f"{self.nombre}, {self.edad} años"

    def __repr__(self):
        return f"Persona('{self.nombre}', {self.edad})"

p = Persona("Ana", 30)
print(p)        # Ana, 30 años
print([p])      # [Persona('Ana', 30)]
```

### Ducks? (Duck Typing)  
- "Si camina como un pato y suena como un pato, es un pato".  
- En Python, no importa el tipo explícito, sino si **tiene los métodos esperados**.  
```python
class Pato:
    def hablar(self):
        print("Cuac")

class Persona:
    def hablar(self):
        print("Hola")

def hazlo_hablar(obj):
    obj.hablar()

hazlo_hablar(Pato())     # Cuac
hazlo_hablar(Persona())  # Hola
```

---

### Uso de diccionarios para armar funciones  
Se puede aprovechar un **diccionario de funciones** para simular un switch o polimorfismo simple:  
```python
def sumar(a, b): return a + b
def restar(a, b): return a - b
def multiplicar(a, b): return a * b

operaciones = {
    "suma": sumar,
    "resta": restar,
    "multi": multiplicar
}

print(operaciones["suma"](3, 4))   # 7
print(operaciones["multi"](3, 4))  # 12
```



## Multiherencia  

La **multiherencia** ocurre cuando una clase hereda de más de una clase padre.  
En Python se permite y es común en ciertos patrones de diseño.  

```python
class A:
    def saludar(self):
        print("Hola desde A")

class B:
    def saludar(self):
        print("Hola desde B")

class C(A, B):
    pass

c = C()
c.saludar()  # Hola desde A (prioridad por orden de herencia)
```

---

### Diferencias  
- **Herencia simple:** solo un padre → jerarquía clara.  
- **Multiherencia:** varios padres → más flexible, pero puede traer conflictos.  

---

### Ventajas  
- Permite reutilizar código de múltiples fuentes.  
- Útil para **mezclas (mixins)** → clases pequeñas que agregan funcionalidades específicas.  

```python
class LoggerMixin:
    def log(self, msg):
        print(f"[LOG] {msg}")

class Base:
    def run(self):
        print("Ejecutando...")

class App(Base, LoggerMixin):
    pass

a = App()
a.run()        # Ejecutando...
a.log("OK")    # [LOG] OK
```

---

### Desafíos  
- Ambigüedad si dos clases padres tienen el mismo método.  
- Puede complicar el **mantenimiento** y la **legibilidad** del código.  

---

### Uso adecuado  
- Usar **mixins** para agregar comportamientos concretos.  
- Mantener jerarquías claras.  
- Evitar multiherencia profunda (difícil de seguir).  

---

## Conflictos de la multiherencia  

Cuando varias clases padres definen el mismo método, Python necesita una regla para decidir cuál usar.  

Se resuelve usando el **MRO (Method Resolution Order)** → orden en que se buscan los métodos.  

```python
class A:
    def saludar(self): print("A")

class B:
    def saludar(self): print("B")

class C(A, B): pass

class D(B, A): pass

print(C.mro())  # [C, A, B, object]
print(D.mro())  # [D, B, A, object]

C().saludar()  # A
D().saludar()  # B
```

---

### Resolución del conflicto  
Python usa el algoritmo **C3 linearization** para determinar el orden de búsqueda.  
- Se puede inspeccionar con `.mro()` o `help(Clase)`.  

---

### El problema del diamante  
Sucede cuando una clase hereda de dos clases que comparten un ancestro común.  

```python
class A:
    def saludar(self): print("A")

class B(A):
    def saludar(self): print("B")

class C(A):
    def saludar(self): print("C")

class D(B, C): pass

D().saludar()       # B (por MRO)
print(D.mro())      # [D, B, C, A, object]
```

Gracias al **MRO**, Python evita llamar dos veces a la misma clase en el diamante.  
  
## Clases abstractas  
- Una **clase abstracta** es una clase que no puede instanciarse directamente.  
- Sirve como **plantilla** para que otras clases la implementen.  
- Se definen con el módulo `abc` (`Abstract Base Classes`).  

```python
from abc import ABC, abstractmethod

class Animal(ABC):  # Hereda de ABC → es abstracta
    @abstractmethod
    def sonido(self):
        pass

# No se puede hacer: a = Animal() ❌
```

---

## Métodos abstractos  
- Se definen con el decorador `@abstractmethod`.  
- Obligan a las subclases a implementar ese método.  
- Si una subclase no implementa todos los métodos abstractos, tampoco se puede instanciar.  

```python
class Perro(Animal):
    def sonido(self):
        return "Guau"

class Gato(Animal):
    def sonido(self):
        return "Miau"

p = Perro()
print(p.sonido())  # Guau
```

---

## Características clave  
- Se usan para **definir interfaces**.  
- Se pueden mezclar con métodos **concretos** (implementados en la clase abstracta).  

```python
class Figura(ABC):
    @abstractmethod
    def area(self):
        pass
    
    def descripcion(self):
        return "Soy una figura geométrica"

class Cuadrado(Figura):
    def __init__(self, lado):
        self.lado = lado
    
    def area(self):
        return self.lado * self.lado

c = Cuadrado(5)
print(c.area())         # 25
print(c.descripcion())  # Soy una figura geométrica
```


## Iterables  

Un **iterable** es cualquier objeto que se puede recorrer con un bucle `for`.  
Ejemplos: listas, tuplas, diccionarios, strings, sets.  

---

### Iterar sobre estructuras de datos  

#### Ejemplo iterable 1  
```python
lista = [1, 2, 3, 4]
for elemento in lista:
    print(elemento)
# 1
# 2
# 3
# 4
```

#### Ejemplo iterable 2  
```python
frutas = {"manzana": 3, "pera": 2, "plátano": 5}
for fruta, cantidad in frutas.items():
    print(fruta, cantidad)

print('---')
print(frutas.items())
print('---')
x, y = 0, 1
```

#### Iterador  
Un **iterador** es el objeto que devuelve los elementos de un iterable, uno a la vez.  
Se obtiene con `iter()` y se recorre con `next()`.  

```python
numeros = [10, 20, 30]
it = iter(numeros)

print(next(it))  # 10
print(next(it))  # 20
print(next(it))  # 30
# print(next(it))  # StopIteration
```

---

### Forma básica de hacer una estructura iterable  

Para crear una clase iterable:  
1. Implementar `__iter__` → devuelve un **iterador**.  
2. Implementar `__next__` en el iterador → devuelve el siguiente elemento o `StopIteration`.  

```python
class Contador:
    def __init__(self, limite):
        self.limite = limite
        self.actual = 0

    def __iter__(self):
        return self
    
    def __next__(self):
        if self.actual < self.limite:
            self.actual += 1
            return self.actual
        raise StopIteration

for num in Contador(5):
    print(num)
# 1 2 3 4 5
```

---

### Ejemplos de iteradores personalizados  

#### Iterador de pares  
```python
class Pares:
    def __init__(self, maximo):
        self.maximo = maximo
        self.n = 0
    
    def __iter__(self):
        return self
    
    def __next__(self):
        self.n += 2
        if self.n <= self.maximo:
            return self.n
        else:
            raise StopIteration

for p in Pares(10):
    print(p)
# 2 4 6 8 10
```

#### Iterador infinito  
```python
class Naturales:
    def __init__(self):
        self.n = 0

    def __iter__(self):
        return self

    def __next__(self):
        self.n += 1
        return self.n

nums = iter(Naturales())
for _ in range(5):
    print(next(nums))
# 1 2 3 4 5
```


---

## Generadores  

- Los **generadores** son una forma más sencilla de crear iteradores.  
- Se definen con funciones que usan `yield`.  
- Ahorran memoria porque producen los valores **uno por uno** en lugar de almacenarlos todos.  

```python
def cuenta_hasta(n):
    x = 1
    while x <= n:
        yield x
        x += 1

for num in cuenta_hasta(5):
    print(num)
# 1 2 3 4 5
```

### Generador infinito  
```python
def naturales():
    n = 1
    while True:
        yield n
        n += 1

g = naturales()
for _ in range(5):
    print(next(g))
# 1 2 3 4 5
```

### Generadores con sintaxis de comprensión  
```python
cuadrados = (x*x for x in range(5))
print(list(cuadrados))  # [0, 1, 4, 9, 16]
```


