
# AC3 (Iteradores)



# Programación Funcional

- Generadores
- Funciones Generadoras

---
## Funciones Generadoras

- `map(fun, iterable)`
- `zip(iter_1, iter_2)`
- `filter(fun, iterable)`

- `enumerate(iterable)`
- `reduce(fun, itreable)

---

## `map(func, iterable)`

Aplica una función a cada elemento del iterable y devuelve un generador.

```python
nums = [1, 2, 3, 4, 5]
cuadrados = map(lambda x: x**2, nums)
print(cuadrados)
print(list(cuadrados))
```

---

>[!example] Ejemplo 1
> Crear una función que dadas dos listas, retorne la suma y diferencia entre ellas, usando `map()`
>
> Ejemplo:
>```text
>Listas Originales:
>[6, 5, 3, 9]
>[0, 1, 7, 7]
>
>Resultado:
>[(6, 6), (6, 4), (10, -4), (16, 2)]
>```

---

>[!example] Ejemplo 2
> Crear una función que dadas dos listas, retorne el número total de pares iguales, (teniendo en cuenta la posición) usando `map()`.
>
> Ejemplo:
>```text
>Original lists:
>[1, 2, 3, 4, 5, 6, 7, 8]
>[2, 2, 3, 1, 2, 6, 7, 9]
>Pares iguales:
>4
>```

---

## `filter(func, iterable)`
Filtra elementos de un iterable según una condición (función booleana).

```python
nums = [1, 2, 3, 4, 5, 6]
pares = filter(lambda x: x % 2 == 0, nums)
print(list(pares))
```

---

>[!example] Ejemplo 1
>Cree una función que retorne un generador de las fechas entre dos límites. Es decir, las fechas que se encuentran desde una fecha inicial hasta una fecha final (inclusive). Pueden usar `datetime()`
>
>```text
>init_date = "2021-01-01"  
>end_date = "2028-12-31"
>Fechas Iniciales:
>['2022-10-21', '2022-02-22', '2020-07-12', '2020-03-21', '2022-08-02', '2020-06-27', '2021-11-20', '2023-08-17', '2022-11-10', '2023-05-08']
> Fechas Filtradas:
>['2022-10-21', '2022-02-22', '2022-08-02', '2021-11-20', '2023-08-17', '2022-11-10', '2023-05-08']
>```
>

---
## `zip(iter1, iter2, ...)`

Combina varios iterables en **tuplas emparejadas**.

```python
nombres = ["Ana", "Beto", "Carlos"]
edades = [20, 25, 30]
combinados = zip(nombres, edades)
print(list(combinados))  
```

---

```python
nombres = ["Ana", "Beto", "Carlos", "Juan"]
edades = [20, 25, 30]
combinados = zip(nombres, edades)
print(list(combinados))  
```


```python
nombres = ["Ana", "Beto", "Carlos"]
edades = [20, 25, 30, 45]
combinados = zip(nombres, edades)
print(list(combinados))  
```

---

```python
from itertools import zip_longest
  
list1 = [1, 2, 3]  
list2 = ['a', 'b']  
list3 = ['X', 'Y', 'Z', 'W']  
  
result_default = list(zip_longest(list1, list2, list3))  
print(f"(1): {result_default}")  
  
result_custom = list(zip_longest(list1, list2, list3, fillvalue='-'))  
print(f"(2): {result_custom}")
```

---

## `enumerate(iterable, start=0)`
Devuelve pares `(índice, valor)` al recorrer un iterable.

```python
frutas = ["manzana", "pera", "uva"]
for i, fruta in enumerate(frutas, start=1):
    print(i, fruta)
```

---

```python
weekdays = ['Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes']
mydict = enumerate(weekdays)
print(type(mydict))
print(dict(mydict))
```

---

## `reduce(func, iterable)` 
Aplica acumulativamente una función binaria a los elementos de un iterable.  

Es como "plegar" la lista en un único valor.

```python
from functools import reduce

listas = [[1, 2], [3, 4], [5, 6, 7]]
unida = reduce(lambda a, b: a + b, listas)
print(unida)
```

---

```python
listas = [[1, 2], [3, 4], [5, 6, 7]]  
unida = []  
for lista in listas:  
	print("---\n")
	print(f"{unida} + {lista}")
	unida += lista  
	print(f"= {unida}")
print(unida)
```

---

```python
fonda = {
	'Choripan': 4,
	'Sopaipillas': 3,
	'Anticucho': 6,
	'Asado': 0,
}

var_1 = filter(lambda x: len(x) > 0, fonda.keys())
var_2 = map(lambda x: x * 2 , filter(lambda x: x % 2 == 0, fonda.values()))

print(list(zip(var_1, var_2)))
```

---


![[../Resources/Pasted image 20250923124208.png]]

---

## Funciones Extra

- `all()
- `any()`

---

### `all()`

La función integrada `all(iterable)` devuelve:
- `True` si **todos** los elementos del iterable son verdaderos
- `False` si encuentra al menos un elemento falso

---

```python
print(all([True, True, True]))
print(all([True, False, True]))
print(all([]))  
```

---

Cree una función que diga si todos los números de una lista son pares y retorne un booleano.

---

```python
nums = [2, 4, 6, 8]
print(all(n % 2 == 0 for n in nums))
```

---

### `any()`

La función integrada `any(iterable)` devuelve:
- `True` si **al menos un** elemento del iterable es verdadero
- `False` si **todos** los elementos son falsos

```python
print(any([True, False, False]))
print(any([False, False, False]))
print(any([]))  
```

---

### `Counter`

```python
from collections import Counter

frutas = ["manzana", "pera", "manzana", "uva", "pera", "manzana"]
conteo = Counter(frutas)

print(conteo)  
print(conteo.most_common(2))
```

---

# AC4