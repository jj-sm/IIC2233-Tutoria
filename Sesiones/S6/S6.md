
# Interfaces Gráficas

```python
import sys  
from PyQt5.QtWidgets import QWidget, QApplication  
  
  
class MiVentana(QWidget):  
    def __init__(self) -> None:  
        super().__init__()  
  
        # Definimos la geometría de la ventana.  
        # Parámetros: (x_superior_izq, y_superior_izq, ancho, alto)        self.setGeometry(200, 100, 300, 300)  
  
        # Podemos dar nombre a la ventana (Opcional).  
        self.setWindowTitle('Mi Primera Ventana')  
  
  
if __name__ == '__main__':  
    def hook(type, value, traceback) -> None:  
        print(type)  
        print(traceback)  
    sys.__excepthook__ = hook  
  
    app = QApplication([])  # Creamos las base de la app: QApplication.  
    ventana = MiVentana()   # Construimos un QWidget que será nuestra ventana.  
    ventana.show()          # Mostramos la ventana.  
    sys.exit(app.exec())    # La aplicación se inicia con app.exec().  
                            # Esto habilita el loop de eventos y retorna un                            # código de salida que luego lo toma "sys.exit()".
```


---

# PyQt5

## QApplication
- Representa la **aplicación completa** de PyQt.
- Gestiona el **loop de eventos**, que permite que la interfaz responda a interacciones del usuario (clics, teclas, movimientos de mouse).
- Solo puede existir **una instancia** por aplicación.
- Puede recibir **argumentos de línea de comandos** (`sys.argv`) para configurar la app.
- Ejemplo:
```python
import sys
from PyQt5.QtWidgets import QApplication

app = QApplication([])   # Lista vacía si no se pasan argumentos
```

---

## QWidget
- Clase base de todos los widgets (ventanas, contenedores, botones, etc.).
- Permite recibir **eventos del sistema** y mostrar contenido.
- Métodos importantes:
  - `show()`: muestra el widget en pantalla.
  - `setGeometry(x, y, ancho, alto)`: define posición y tamaño.
  - `setWindowTitle("Título")`: asigna un nombre a la ventana.
- Ejemplo:
```python
ventana = QWidget()
ventana.setGeometry(100, 100, 400, 300)
ventana.setWindowTitle("Mi Ventana")
ventana.show()
```

---

## QPushButton
- Botón interactivo que el usuario puede **clicar**.
- Conecta con funciones mediante **señales**:
  - `.clicked.connect(funcion)` → ejecuta `funcion` cuando se hace clic.
- Ejemplo:
```python
from PyQt5.QtWidgets import QPushButton

boton = QPushButton("Haz clic")
boton.clicked.connect(mi_funcion)  # mi_funcion se ejecuta al hacer clic
```

---

## QLabel
- Widget para mostrar **texto o imágenes**.
- Solo **lectura**, no editable por el usuario.
- Ejemplo:
```python
from PyQt5.QtWidgets import QLabel

etiqueta = QLabel("Hola Mundo")
etiqueta.setAlignment(Qt.AlignCenter)  # Opcional: centrar el texto
```

---

## QLineEdit
- Campo de texto **editable** por el usuario.
- Métodos y señales importantes:
  - `.text()` → obtiene el contenido actual.
  - `.setText("texto")` → asigna un valor.
  - `.returnPressed.connect(funcion)` → ejecuta `funcion` al presionar Enter.
- Ejemplo:
```python
entrada = QLineEdit()
entrada.returnPressed.connect(procesar_texto)
```

---

## QHBoxLayout
- Layout **horizontal**: organiza widgets en fila.
- Permite un diseño dinámico y responsivo, evitando posiciones fijas.
- Se agregan widgets con `.addWidget(widget)`.
- Ejemplo:
```python
from PyQt5.QtWidgets import QHBoxLayout

layout_horizontal = QHBoxLayout()
layout_horizontal.addWidget(boton1)
layout_horizontal.addWidget(boton2)
```

---

## QVBoxLayout
- Layout **vertical**: organiza widgets en columna.
- Similar a `QHBoxLayout`, pero apila los widgets de arriba a abajo.
- Se puede combinar con layouts horizontales para diseños más complejos.
- Ejemplo:
```python
from PyQt5.QtWidgets import QVBoxLayout

layout_vertical = QVBoxLayout()
layout_vertical.addWidget(etiqueta)
layout_vertical.addWidget(entrada)
layout_vertical.addWidget(boton)
```

---

## Buenas prácticas
- Usar **QApplication** antes de crear cualquier widget.
- Mantener **una sola instancia** de QApplication.
- Combinar **QHBoxLayout** y **QVBoxLayout** para estructuras más complejas.
- Conectar widgets a funciones mediante **señales y slots** para manejar eventos.
- Evitar posiciones absolutas usando layouts para que la ventana sea **responsiva**.

---

> ¿Cómo podemos centrar la ventana al iniciarla?

```python
import sys  
from PyQt5.QtWidgets import QWidget, QApplication  
  
  
class MiVentana(QWidget):  
    def __init__(self) -> None:  
        super().__init__()  
  
        # Definimos la geometría de la ventana.  
        # Parámetros: (x_superior_izq, y_superior_izq, ancho, alto)        self.setGeometry(*self.center(300, 300))  
  
        # Podemos dar nombre a la ventana (Opcional).  
        self.setWindowTitle('Mi Primera Ventana')  
  
    @staticmethod  
    def center(width, height) -> tuple[int, int, int, int]:  
        x = (QApplication.desktop().width() - width) // 2  
        y = (QApplication.desktop().height() - height) // 2  
        return x, y, width, height  
  
  
if __name__ == '__main__':  
    def hook(type, value, traceback) -> None:  
        print(type)  
        print(traceback)  
    sys.__excepthook__ = hook  
  
    app = QApplication([])  
    ventana = MiVentana()  
    ventana.show()  
    sys.exit(app.exec())
```

---
# Eventos y Señales

## Conceptos clave
- **GUI basada en eventos**: la aplicación detecta eventos (mouse, teclado, señales) y los procesa.
- Elementos del modelo de eventos:
  1. **Fuente del evento**: objeto que genera el cambio.
  2. **Objeto evento**: encapsula información del evento.
  3. **Objeto destino**: recibe la notificación del evento.

- **Signals y Slots**: mecanismo de PyQt para manejar eventos y comunicar widgets.
  - `signal` → emite el evento.
  - `slot` → función o método que recibe el evento.

---

## Manejo de botones y señales
- Cada `QPushButton` puede conectarse a un slot con `.clicked.connect(funcion)`.
- `sender()` permite identificar cuál objeto envió la señal.
- Ejemplo de slot:
```python
def boton_clickeado(self):
    boton = self.sender()
    idx = self.grilla.indexOf(boton)
    posicion = self.grilla.getItemPosition(idx)
    self.label2.setText(f'Botón {idx}, fila/columna: {posicion[:2]}')
```

---

Un **slot** es cualquier función o método que recibe la señal emitida por un **signal**. Puede ser propio de un widget o una función definida por el programador.

---

## Slot simple para un botón
```python
from PyQt5.QtWidgets import QApplication, QWidget, QPushButton, QLabel, QVBoxLayout
import sys

class MiVentana(QWidget):
    def __init__(self):
        super().__init__()
        self.label = QLabel("No se ha presionado el botón")
        self.boton = QPushButton("Presióname")
        self.boton.clicked.connect(self.actualiza_label)  # Slot conectado a clicked

        layout = QVBoxLayout()
        layout.addWidget(self.label)
        layout.addWidget(self.boton)
        self.setLayout(layout)

    def actualiza_label(self):
        # Este método es el slot
        self.label.setText("¡Botón presionado!")

if __name__ == "__main__":
    app = QApplication([])
    ventana = MiVentana()
    ventana.show()
    sys.exit(app.exec())
```

---
## Eventos de mouse
- Sobrescribir métodos de `QWidget`:
  - `mousePressEvent(event)`
  - `mouseReleaseEvent(event)`
  - `mouseMoveEvent(event)` (requiere `setMouseTracking(True)` para detectar movimiento sin click)
- Permite saber dónde se hizo click o se mueve el mouse dentro del widget.

---

## Eventos de teclado
- Sobrescribir métodos de `QWidget`:
  - `keyPressEvent(event)` → detectar tecla presionada
  - `keyReleaseEvent(event)` → detectar tecla liberada
- Ejemplo:
```python
def keyPressEvent(self, event):
    self.label.setText(f'Tecla presionada: {event.text()}')
```

---

## Señales personalizadas (`pyqtSignal`)
- Definidas como **atributo de clase** de un `QObject` o `QWidget`.
- Se emiten con `emit()` y se conectan con `connect(funcion)`.
- Se pueden enviar datos como argumentos (`str`, `int`, `tuple`, `dict`).

### Ejemplo básico:
```python
class Ventana(QWidget):
    senal_click = pyqtSignal()
    
    def mousePressEvent(self, event):
        self.senal_click.emit()
```

### Ejemplo con información:
```python
senal_texto = pyqtSignal(str)
senal_coordenadas = pyqtSignal(int, int)

# Emitiendo la señal:
self.senal_texto.emit(self.etiqueta.text())
self.senal_coordenadas.emit(event.x(), event.y())
```

- Cada instancia de la clase obtiene su propia señal única, aunque se defina como atributo de clase.
- Los slots conectados reciben los argumentos emitidos.

---

## Buenas prácticas
- Conectar señales a slots **sin paréntesis** para pasar la referencia de la función.
- Usar layouts (`QVBoxLayout`, `QHBoxLayout`, `QGridLayout`) en lugar de posiciones absolutas.
- Actualizar labels con `setText()` y, si es necesario, `repaint()` para refrescar inmediatamente.
- Explorar eventos adicionales de mouse: `enterEvent`, `leaveEvent`, `dragEnterEvent`.
- Las señales permiten comunicación entre widgets y ventanas de forma flexible.




---

![[../Resources/Screenshot 2025-10-07 at 5.01.10 PM.png]]