
# Recap Iterables e Iteradores

---

Un *iterable* es un objeto que contiene una colección de elementos y que puede ser recorrido o *iterado* uno a uno.

```python
una_lista = ['i', 'i', 'c', '2', '2', '3', '3']

for char in una_lista:
	print(char)
```

---

Un *iterador* es un objeto que proporciona un mecanismo para *iterar sobre un iterable*, avanzando de un elemento al siguiente hasta que se han recorrido todos los elementos.

```python
tutores = {"Juan", "José", "María", "Antonia"}
tutores_iter_1 = iter(tutores)
tutores_iter_2 = tutores.__iter__()

print(type(tutores_iter_1))
print(type(tutores_iter_2))
```

---

```python
tutores = {"Juan", "José", "María", "Antonia"}
tutores_iter_1 = iter(tutores)

for i in range(len(tutores_iter_1)):
	print(tutores_iter_1.__next__())

```

---

```python
tutores = {"Juan", "José", "María", "Antonia"}
tutores_iter_1 = iter(tutores)

while True:
	print(tutores_iter_1.__next__())
```

---

Un **iterable** se puede utilizar/recorrer múltiples veces; en cambio un **iterador** solo puede utilizarse una única vez.  

```python
tutores = {"Juan", "José", "María", "Antonia"}
tutores_iter_1 = iter(tutores)

print(next(tutores_iter_1))
print(next(tutores_iter_1))
print(next(tutores_iter_1))
print(next(tutores_iter_1))
print(next(tutores_iter_1))
```


---

```python
tutores = {"Juan", "José", "María", "Antonia"}
tutores_iter_1 = iter(tutores)

print(list(tutores_iter_1))
print(next(tutores_iter_1))
```

---


```python
tutores = {"Juan", "José", "María", "Antonia"}
tutores_iter_1 = iter(tutores)

bool_tutor = True if "Juan" in tutores_iter_1 else False
print(bool_tutor)
print(next(tutores_iter_1))
print(next(tutores_iter_1))
```

---

```python
tutores = {"Juan", "José", "María", "Antonia"}
tutores_iter_1 = iter(tutores)

bool_tutor = True if "Antonia" in tutores_iter_1 else False
print(bool_tutor)
print(next(tutores_iter_1))
```

---
## ¿Cómo podemos manejar el `StopIteration`?

---

- `for elemento in conjunto`
- `try/except`
- `next(iterador, fallback)` 

---
### `for elemento in conjunto`

```python
planetas = ['Tierra', 'Marte', 'Júpiter', 'Saturno', 'Mercurio']
planetas_iterador = planetas.__iter__()

for planeta in planetas_iterador:
	print(f'-> {planeta}')
```

---
### `for elemento in conjunto`

...

---

### `next(iterador, fallback)` 

```python
planetas = ['Tierra', 'Marte', 'Júpiter', 'Saturno', 'Mercurio']
planetas_iterador = planetas.__iter__()

while True:
	word = next(planetas_iterador, None)
	
	if word is not None:
		print(f'-> {word}')
	
	else:
		print(f'El iterador se agotó, next retornó {word}')
		break
```

---
## Clases personalizadas

```python
class TutorIterable:  
    def __init__(self, data: list | set) -> None:  
        self.data = list(data).copy()  
  
    def __iter__(self):  
        return self  
  
    def __next__(self):  
        if not self.data:  
            raise StopIteration  
        return self.data.pop(0)
```

...

---

Importante que para crear una clase Iterable, esta debe tener `__iter__` y `__next__` o `__getitem__`

---

# Preguntas de Pruebas Pasadas


---

![[../Resources/Pasted image 20250910003622.png]]

---

![[../Resources/Pasted image 20250910003854.png]]

---

![[../Resources/Pasted image 20250910003923.png]]

---

![[../Resources/Pasted image 20250910004152.png]]

---

