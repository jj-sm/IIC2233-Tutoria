# S7 - PyQt5 y Threading

---

## Threads?

Permite que tu código realice múltiples tareas de forma concurrente, dando la **apariencia** de que ocurren al mismo tiempo.

Piensa en ellos como diferentes trabajadores colaborando en un mismo proyecto.

### **Creación Básica**

La forma más directa es pasar una función a la clase `Thread`.

```python
import threading
import time

def trabajador():
    print("Empezando a trabajar...")
    time.sleep(2)
    print("Trabajo terminado.")

# Creamos el thread
thread = threading.Thread(target=trabajador)

# Lo iniciamos
thread.start()

print("El thread principal sigue ejecutándose mientras el trabajador trabaja.")
```


---

## Threads con Clases

Para tareas más complejas, es mejor crear una clase que herede de `threading.Thread`. Solo necesitas sobrescribir el método `run()`.

Esto organiza mejor tu código y te permite guardar estados dentro del objeto.

```python
class CuentaOvejas(threading.Thread):
    def __init__(self, nombre):
        super().__init__()
        self.name = nombre

    def run(self):
        # El código aquí se ejecuta cuando llamamos a .start()
        print(f"{self.name} tiene sueño...")
        for i in range(1, 6):
            print(f"({self.name}: {i} oveja{'s' if i > 1 else ''})")
            time.sleep(1)
        print(f"{self.name} se durmió.")

# Creamos e iniciamos el thread desde la clase
pastor = CuentaOvejas("Pastor")
pastor.start()
```


---

## *Race Conditions*

Cuando dos o más threads intentan modificar un mismo recurso (como una variable) al mismo tiempo, los resultados pueden ser caóticos e incorrectos. A esto se le llama **condición de carrera** (*race condition*).

```python
# Ejemplo de un contador compartido que da un resultado incorrecto
valor = 0

def sumador():
    global valor
    for _ in range(10**6):
        valor += 1

t1 = threading.Thread(target=sumador)
t2 = threading.Thread(target=sumador)
t1.start()
t2.start()
t1.join() # Esperamos a que terminen
t2.join()

print(f"El valor final es: {valor}") # No será 2,000,000
```


---

## `Lock`s

Un `Lock` es como una llave para una sección de tu código. Solo el thread que tiene la "llave" (`lock`) puede ejecutar esa parte, llamada **sección crítica**. Los demás deben esperar.

La forma más segura de usarlo es con la sentencia `with`.

```python
valor = 0
lock = threading.Lock() # Creamos el candado

def sumador_seguro():
    global valor
    for _ in range(10**6):
        with lock: # Solo un thread puede estar aquí a la vez. adquire() y release() automáticos
            valor += 1

# ... (crear e iniciar threads como antes)
# Ahora el resultado sí será 2,000,000
```


---

## `Event`

Un `Event` es una señal simple. Un thread puede esperar a que ocurra un evento (`.wait()`) y otro thread puede activarlo (`.set()`).

Es perfecto para sincronizar un punto de partida, como una carrera.

```python
import threading
import time

senal_inicio = threading.Event()

def corredor():
    print("Corredor listo en la línea de partida...")
    senal_inicio.wait() # El thread se pausa aquí
    print("¡El corredor arranca!")

corredor_thread = threading.Thread(target=corredor)
corredor_thread.start()

time.sleep(3)
print("¡PREPARADOS, LISTOS, YA!")
senal_inicio.set() # Activamos la señal y el corredor arranca
```


---

## `.join()`

El método `.join()` pausa la ejecución de un thread (por ejemplo, el principal) hasta que otro thread haya completado su tarea en el método `run()`.

Es fundamental para asegurarte de que todas las tareas han finalizado antes de continuar.

```python
print("Iniciando un trabajo importante...")
worker = CuentaOvejas("Trabajador")
worker.start()

# El thread principal espera a que el worker termine
worker.join()

print("El trabajo importante ha finalizado. Ahora podemos continuar.")
```